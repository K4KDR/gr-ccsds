<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GNU Radio&#39;s CCSDS Package: M-PSK demodulation chain</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio&#39;s CCSDS Package
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_mpsk_receiver.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">M-PSK demodulation chain </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="page_mpsk_receiver_introduction"></a>
Introduction</h1>
<p>This pages describes two general purpose M-PSK demodulation chains which can be used to synchronize and demodulate arbitrary M-PSK signals. The first one is working on hard bit decisions(not implemented in gnuradio 3.7), while the latter on uses soft-bit decisions. These blocks are available as GRC blocks in <em>apps/blocks/mpsk_demod_hard.grc</em> and <em>apps/blocks/mpsk_demod_soft.grc</em> </p>
<p>The output of these two demodulators still have phase ambiguity, which has to be resolved either by differential encoding/decoding or by <a class="el" href="page_mpsk_ar.html">M-PSK Phase Ambiguity Resolution</a></p>
<h2><a class="anchor" id="page_mpsk_receiver_introduction_soft"></a>
Soft-bit Decisions</h2>
<p>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized stream of soft-bits (with unresolved phase ambiguity). This is usually followed by the soft-bit decision M-PSK ambiguity resolver and frame synchronization block implemented in <a class="el" href="mpsk__ambiguity__resolver__f_8h.html">ccsds/mpsk_ambiguity_resolver_f.h</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_introduction_hard_or_soft"></a>
Hard- or Soft-bit Decisions</h2>
<p>Soft-bit decisions are recommended when following up with channelcoding (usually viterbi decoding) that can take advantage of the soft-bits. But the output of the soft-bit AR/FS block can also be cast back to hard-bit decisions with the <a class="el" href="softbits__msg__to__bytes__b_8h.html">ccsds/softbits_msg_to_bytes_b.h</a> block so blocks downstream can take hard-bit decisions even when the soft-bit demodulator chain was used. The advantage of this is that the AR and FS profit from the soft-bit correlation, but they meed more recources than using the hard-bit detector block.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Put the ambiguity resolution and frame synchronization into this block as soon as Hierachial blocks can have message ports.</dd></dl>
<h1><a class="anchor" id="page_mpsk_receiver_setup"></a>
Setup</h1>
<p>The Figure below shows the GRC block of the soft-bit M-PSK demodulation chain. The hard-bit demodulation chain is identical to the soft-bit one except for a different detector and a byte stream instead of a float stream as output. Both's parameters and blocks are described in the next Sections.</p>
<div class="image">
<img src="mpsk_demod_soft.png" alt="mpsk_demod_soft.png"/>
<div class="caption">
Setup of the soft-bit M-PSK demodulation chain of this package</div></div>
 <h1><a class="anchor" id="page_mpsk_receiver_parameters"></a>
Parameters</h1>
<h2><a class="anchor" id="page_mpsk_receiver_samp_rate"></a>
samp_rate</h2>
<p>The sampling rate of the incomming signal.</p>
<h2><a class="anchor" id="page_mpsk_receiver_M"></a>
M</h2>
<p>The Modulation order of the signal. Must be a power of two. For BPSK (i.e. M=2) the previously developed BPSK demodulator <em>bpsk_demod</em> can be used as an alternative.</p>
<h2><a class="anchor" id="page_mpsk_receiver_osf"></a>
osf</h2>
<p>Oversampling factor, or samples per symbol. The receiver block performs a decimation by this factor. Oversampling must be at least two.</p>
<h2><a class="anchor" id="page_mpsk_receiver_alpha"></a>
alpha</h2>
<p>Rollof factor for the RX filter.</p>
<h2><a class="anchor" id="page_mpsk_receiver_asm"></a>
Attached sync marker (ASM)</h2>
<p>The repeating sequence used for ambiguity resolution as a hex string. The sequence length must be an integer multiple of bytes and thus the string must contain an even number of characters.</p>
<h2><a class="anchor" id="page_mpsk_receiver_frame_len"></a>
Frame length</h2>
<p>Length of the data between two sync markers in bytes.</p>
<h2><a class="anchor" id="page_mpsk_receiver_sym_rate"></a>
sym_rate</h2>
<p>Symbol rate of the incomming signal given by <code>samp_rate</code> / <code>osf</code>.</p>
<h1><a class="anchor" id="page_mpsk_receiver_blocks"></a>
Blocks</h1>
<h2><a class="anchor" id="page_mpsk_receiver_filter"></a>
RX filter</h2>
<p>The RX filter cuts out all frequency parts with a frequency higher than the symbol rate and thus filtering out all the noise that was introduced due to oversampling. The concatenation of this filter and the TX filter should fulfill the first Nyquist criterion. The two most common TX/RX filter combinations are a brick wall filter (or no filtering at all) at the TX side together with a raised cosine filter at the RX side, or a root raised cosine filter at each TX and RX side.</p>
<p>These two options are predefined in the block and by default the RRC filter is used. The raised cosine filter can be used by enabling the two RRC Filter path and disabling the single Root Raised Cosine Filter path.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>In the future this block should be able to switch between the two filters and leaving the GRC definition untouched. </dd></dl>
<h3><a class="anchor" id="page_mpsk_receiver_filter_rrc"></a>
Root Raised Cosine Filter</h3>
<p>A standard GRC RRC filter implementation is used.</p>
<h3><a class="anchor" id="page_mpsk_receiver_filter_rc"></a>
Raised Cosine Filter</h3>
<p>There is no Raised Cosine filter block in GRC, the concatenation of two standard GRC RRC filters is used instead which is the same as using one RC filter.</p>
<h2><a class="anchor" id="page_mpsk_receiver_dll"></a>
Delay locked loop</h2>
<p>Estimate the timing error introduced by a propagation delay and interpolate the signal at the correct time instances at symbol rate. This block performs a decimation by <code>osf</code>. The DLL is implemented in <a class="el" href="dll__cc_8h.html">ccsds/dll_cc.h</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_agc2"></a>
Automatic Gain Control</h2>
<p>The incomming signal energy can vary based on the TX power on the sending side and the attenuation between transmitter and receiver. At this point in the chain the relative power level between samples is no longer essential, so the overall signal level is regulated to have an average signal energy of 1. This is performed by this block. A standard GRC AGC2 implementation is used.</p>
<h2><a class="anchor" id="page_mpsk_receiver_pll"></a>
Phase locked loop</h2>
<p>Estimates the signal's phase and local frequency offset (after the LO). Sends frequency corrections to the LO and compensates the phase offset of the samples. The PLL is implemented in <a class="el" href="pll__cc_8h.html">ccsds/pll_cc.h</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_detector"></a>
M-PSK Detector</h2>
<p>Detects the received M-PSK symbols based on the synchronized samples. Two different implementations are available.</p>
<h3><a class="anchor" id="page_mpsk_receiver_detector_hard"></a>
Hard-bit Detector</h3>
<p>Performs hard bit decisions and outputs the detected bits in an unpacked bytes containing ld(M) information bits.</p>
<h3><a class="anchor" id="page_mpsk_receiver_detector_soft"></a>
Soft-bit Detector</h3>
<p>Performs soft-bit decisions and outputs ld(M) soft-bit floats per incomming symbol. The soft bits range from -1.0f (very confident zero) over 0.0f (no confidence at all, this could either be a zero or a one) up to 1.0f (very confident one).</p>
<h1><a class="anchor" id="page_mpsk_receiver_introduction"></a>
Introduction</h1>
<p>This pages describes two general purpose M-PSK demodulation chains which can be used to synchronize and demodulate arbitrary M-PSK signals. The first one is working on hard bit decisions, while the latter on uses soft-bit decisions. These blocks are available as GRC blocks in <em>apps/blocks/mpsk_demod_hard.grc</em> and <em>apps/blocks/mpsk_demod_soft.grc</em> </p>
<p>The output of these two demodulators still have phase ambiguity, which has to be resolved either by differential encoding/decoding or by <a class="el" href="page_mpsk_ar.html">M-PSK Phase Ambiguity Resolution</a></p>
<h2><a class="anchor" id="page_mpsk_receiver_introduction_hard"></a>
Hard-bit Decisions</h2>
<p>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized, unpacked (ld(M) information bits per byte) stream of bits (with unresolved phase ambiguity). This block is usually followed by the hard decision M-PSK ambiguity resolver implemented in <a class="el" href="classccsds__mpsk__ambiguity__resolver__bb.html">ccsds_mpsk_ambiguity_resolver_bb</a> and the frame synchronization implemented in <a class="el" href="classccsds__frame__sync__b.html">ccsds_frame_sync_b</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_introduction_soft"></a>
Soft-bit Decisions</h2>
<p>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized stream of soft-bits (with unresolved phase ambiguity). This is usually followed by the soft-bit decision M-PSK ambiguity resolver and frame synchronization block implemented in <a class="el" href="classccsds__mpsk__ambiguity__resolver__f.html">ccsds_mpsk_ambiguity_resolver_f</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_introduction_hard_or_soft"></a>
Hard- or Soft-bit Decisions</h2>
<p>Soft-bit decisions are recommended when following up with channelcoding (usually viterbi decoding) that can take advantage of the soft-bits. But the output of the soft-bit AR/FS block can also be cast back to hard-bit decisions with the <a class="el" href="classccsds__softbits__msg__to__bytes__b.html">ccsds_softbits_msg_to_bytes_b</a> block so blocks downstream can take hard-bit decisions even when the soft-bit demodulator chain was used. The advantage of this is that the AR and FS profit from the soft-bit correlation, but they meed more recources than using the hard-bit detector block.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Put the ambiguity resolution and frame synchronization into this block as soon as Hierachial blocks can have message ports.</dd></dl>
<h1><a class="anchor" id="page_mpsk_receiver_setup"></a>
Setup</h1>
<p>The Figure below shows the GRC block of the soft-bit M-PSK demodulation chain. The hard-bit demodulation chain is identical to the soft-bit one except for a different detector and a byte stream instead of a float stream as output. Both's parameters and blocks are described in the next Sections.</p>
<div class="image">
<img src="mpsk_demod_soft.png" alt="mpsk_demod_soft.png"/>
<div class="caption">
Setup of the soft-bit M-PSK demodulation chain of this package</div></div>
 <h1><a class="anchor" id="page_mpsk_receiver_parameters"></a>
Parameters</h1>
<h2><a class="anchor" id="page_mpsk_receiver_samp_rate"></a>
samp_rate</h2>
<p>The sampling rate of the incomming signal.</p>
<h2><a class="anchor" id="page_mpsk_receiver_M"></a>
M</h2>
<p>The Modulation order of the signal. Must be a power of two. For BPSK (i.e. M=2) the previously developed BPSK demodulator <em>bpsk_demod</em> can be used as an alternative.</p>
<h2><a class="anchor" id="page_mpsk_receiver_osf"></a>
osf</h2>
<p>Oversampling factor, or samples per symbol. The receiver block performs a decimation by this factor. Oversampling must be at least two.</p>
<h2><a class="anchor" id="page_mpsk_receiver_alpha"></a>
alpha</h2>
<p>Rollof factor for the RX filter.</p>
<h2><a class="anchor" id="page_mpsk_receiver_asm"></a>
Attached sync marker (ASM)</h2>
<p>The repeating sequence used for ambiguity resolution as a hex string. The sequence length must be an integer multiple of bytes and thus the string must contain an even number of characters.</p>
<h2><a class="anchor" id="page_mpsk_receiver_frame_len"></a>
Frame length</h2>
<p>Length of the data between two sync markers in bytes.</p>
<h2><a class="anchor" id="page_mpsk_receiver_sym_rate"></a>
sym_rate</h2>
<p>Symbol rate of the incomming signal given by <code>samp_rate</code> / <code>osf</code>.</p>
<h1><a class="anchor" id="page_mpsk_receiver_blocks"></a>
Blocks</h1>
<h2><a class="anchor" id="page_mpsk_receiver_lo"></a>
Local oscillator</h2>
<p>The local oscillator shifts the incomminc signal by a frequency estimate it receives over the <a class="el" href="page_lo_feedback.html">Local oscillator frequency correction feedback loop</a> . If no frequency error is received (at the start) it uses a zero frequency estimate and thus does nothing at all until it receives an estimate. The LO is implemented in <a class="el" href="classccsds__local__oscillator__cc.html">ccsds_local_oscillator_cc</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_filter"></a>
RX filter</h2>
<p>The RX filter cuts out all frequency parts with a frequency higher than the symbol rate and thus filtering out all the noise that was introduced due to oversampling. The concatenation of this filter and the TX filter should fulfill the first Nyquist criterion. The two most common TX/RX filter combinations are a brick wall filter (or no filtering at all) at the TX side together with a raised cosine filter at the RX side, or a root raised cosine filter at each TX and RX side.</p>
<p>These two options are predefined in the block and by default the RRC filter is used. The raised cosine filter can be used by enabling the two RRC Filter path and disabling the single Root Raised Cosine Filter path.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>In the future this block should be able to switch between the two filters and leaving the GRC definition untouched. </dd></dl>
<h3><a class="anchor" id="page_mpsk_receiver_filter_rrc"></a>
Root Raised Cosine Filter</h3>
<p>A standard GRC RRC filter implementation is used.</p>
<h3><a class="anchor" id="page_mpsk_receiver_filter_rc"></a>
Raised Cosine Filter</h3>
<p>There is no Raised Cosine filter block in GRC, the concatenation of two standard GRC RRC filters is used instead which is the same as using one RC filter.</p>
<h2><a class="anchor" id="page_mpsk_receiver_dll"></a>
Delay locked loop</h2>
<p>Estimate the timing error introduced by a propagation delay and interpolate the signal at the correct time instances at symbol rate. This block performs a decimation by <code>osf</code>. The DLL is implemented in <a class="el" href="classccsds__dll__cc.html">ccsds_dll_cc</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_agc2"></a>
Automatic Gain Control</h2>
<p>The incomming signal energy can vary based on the TX power on the sending side and the attenuation between transmitter and receiver. At this point in the chain the relative power level between samples is no longer essential, so the overall signal level is regulated to have an average signal energy of 1. This is performed by this block. A standard GRC AGC2 implementation is used.</p>
<h2><a class="anchor" id="page_mpsk_receiver_pll"></a>
Phase locked loop</h2>
<p>Estimates the signal's phase and local frequency offset (after the LO). Sends frequency corrections to the LO and compensates the phase offset of the samples. The PLL is implemented in <a class="el" href="classccsds__pll__cc.html">ccsds_pll_cc</a>.</p>
<h2><a class="anchor" id="page_mpsk_receiver_detector"></a>
M-PSK Detector</h2>
<p>Detects the received M-PSK symbols based on the synchronized samples. Two different implementations are available.</p>
<h3><a class="anchor" id="page_mpsk_receiver_detector_hard"></a>
Hard-bit Detector</h3>
<p>Performs hard bit decisions and outputs the detected bits in an unpacked bytes containing ld(M) information bits.</p>
<h3><a class="anchor" id="page_mpsk_receiver_detector_soft"></a>
Soft-bit Detector</h3>
<p>Performs soft-bit decisions and outputs ld(M) soft-bit floats per incomming symbol. The soft bits range from -1.0f (very confident zero) over 0.0f (no confidence at all, this could either be a zero or a one) up to 1.0f (very confident one). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Nov 30 2015 22:33:44 for GNU Radio&#39;s CCSDS Package by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
