# auto-generated by grc.converter

id: ccsds_conv_decode27
label: Convolutional Decoder (CCSDS)
category: CCSDS/Channelcoding

parameters:
-   id: gen_poly_c1
    label: Generator Polynom C1
    dtype: int
    default: '0x79'
-   id: gen_poly_c2
    label: Generator Polynom C2
    dtype: int
    default: '0xDB'
-   id: punct
    label: Puncturing
    dtype: enum
    default: '0'
    options: [NONE, ECSS_23, ECSS_34, ECSS_56, ECSS_78]
    option_labels: [None, ECSS 2/3, ECSS 3/4, ECSS 5/6, ECSS 7/8]
    option_attributes:
        fcn: ['0', '1', '2', '3', '4']
-   id: num_bits_out
    label: Output bits
    dtype: int
    default: '2040'
-   id: ASM
    label: Sync Marker (hex)
    dtype: string
    default: '''1ACFFC1D'''

inputs:
-   domain: message
    id: in

outputs:
-   domain: message
    id: out
asserts:
- ${ gen_poly_c1 >= 0 }
- ${ gen_poly_c2 >= 0 }
- ${ gen_poly_c1 <= 255 }
- ${ gen_poly_c2 <= 255 }
- ${ num_bits_out > 0 }
- ${ num_bits_out % 8 == 0 }
- ${ len(ASM) % 2 == 0 }

templates:
    imports: import ccsds
    make: ccsds.conv_decode27(${gen_poly_c1}, ${gen_poly_c2}, int(${punct.fcn}), ${num_bits_out},
        ${ASM})

documentation: "Convolutional Decoder with unpuncturing\n\nPerforms unpuncturing of\
    \ incomming softbits by adding erasure softbits at the \npunctured positions and\
    \ convolutional decodes the unpunctured softbits. Outputs\na BLOB with the packed\
    \ decoded bytes.\n\nThe compact generator polynom contains two informations. Encoded\
    \ in the MSB is\nthe information whether the stream should be inverted (MSB set)\
    \ or not (MSB\nunset). Encoded in the 7 less significant bits is the information\
    \ about the\nconnections between the shift registers and the output. The MSB-1\
    \ represents the\ninfluence of the current information bit i(t) while the LSB\
    \ represents the\ninfluence of the information bit i(t-6). A set bit means there\
    \ is a connection,\nwhile an unset bit means there is no.\n\nThe polynomials for\
    \ the convolutional code defined in ECSS can be generated with\n0x79 for c1 and\
    \ 0x5B for c2. Together with the MSB for the inversion of c2 the\ncompact polynomials\
    \ are 0x79 and 0xDB for non puncturing. For puncturing, the\ninversion is not\
    \ performed, so the compact generator polynomials are 0x79 for c1\nand 0x5B for\
    \ c2.\n\nThis block will output num_bits_out decoded bits as packed bytes in a\
    \ BLOB\nmessage. The input consists of a f32vector of floats containing softbits,\
    \ where\n-1.0f corresponds to the strongest zero bit, 0.0f corresponds to an erasure\
    \ and\n1.0f corresponds to the strongest one bit. The number of input softbits\
    \ must be\nchosen in a way that after unpuncturing there are exactly num_bits_out*2+12\n\
    input elements.\n\nThe ASM is used to determine the start and termination state\
    \ of the viterbi\ndecoder. If data that goes into this block has been generated\
    \ by starting with\nzeros as input and additional zeroes are added as tail, provide\
    \ a 2 byte zeros\nASM to make this block use the zero start and stop state."

file_format: 1
