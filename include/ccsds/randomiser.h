#ifndef INCLUDED_CCSDS_RANDOMIZER_H
#define INCLUDED_CCSDS_RANDOMIZER_H

#include <ccsds/api.h>
#include <gnuradio/sync_block.h>

namespace gr {
  namespace ccsds {
     /*!
      *  \brief Combines the input frame with a pseudo random sequence by XOR
      *	operation. The pseudo random sequence is generated by an 8-bit linear
      *	feedback shift register as defined in ECSS.
      *
      *  \ingroup telemetry
      *
      *  The block has an input message port named "in" at which new frames can
      *  arrive. On arrival a new message is created consisting of the input message
      *  XORed with the pseudo random sequence. The LFSR is set to the initial
      *  \c seed state before every block.This new message is then queued in the
      *  output message port named "out".
      */
     class CCSDS_API randomiser : virtual public gr::sync_block
     {
     public:
	typedef boost::shared_ptr<randomiser> sptr;
	/*
	 * We use boost::shared_ptr's instead of raw pointers for all access
	 * to gr_blocks (and many other data structures).  The shared_ptr gets
	 * us transparent reference counting, which greatly simplifies storage
	 * management issues.  This is especially helpful in our hybrid
	 * C++ / Python system.
	 *
	 * See http://www.boost.org/libs/smart_ptr/smart_ptr.htm
	 *
	 * As a convention, the _sptr suffix indicates a boost::shared_ptr
	 */

//	static sptr make(const uint8_t polynomial=0x95, const uint8_t seed=0xFF);
	static sptr make(const uint8_t polynomial, const uint8_t seed);
        /*!
         *  \brief Return a shared_ptr to a new instance of ccsds::randomiser
         *
         *  Create an instance of ccsds_randomiser and return it's shared_ptr.
         *
         *  \param polynomial Polynomial that defines the network of the 8 shift
         *	registers. The MSB encodes whether the last shift register (which is
         *	used for the output) should be used to generate the new input while the
         *	LSB encodes whether the first shift register (that holds the input bit
         *	of the last step should be used to generate the output. Or in ECSS
         *	definition: The MSB holds the coefficient for x^0 up to the LSB which
         *	holds coefficient x^7. x^8 is not encoded as it is always set (due to
         *	the fact that this is a maximum length 8 bit shift register).
         *	The default value is 0x95 which corresponds to the randomiser defined in
         *	ECSS with the polynomial representation x^8+x^7+x^5+x^3+x^0.
         *  \param seed Initial state of the shift registers. MSB corresponds to the
         *	last register (which will be the output on the next step). Default to
         *	all ones as defined in ECSS.
         *  \return Shared pointer to the created block
         */
    };

  } // namespace ccsds
} // namespace gr
#endif /* INCLUDED_CCSDS_RANDOMIZER_H */
