# auto-generated by grc.converter

id: ccsds_randomiser_softbits
label: Pseudo (De)randomiser with Softbits (CCSDS)
category: CCSDS/Telemetry

parameters:
-   id: poly
    label: Generating Polynimoal
    dtype: int
    default: '0x95'
-   id: seed
    label: Seed
    dtype: int
    default: '0xFF'

inputs:
-   domain: message
    id: in

outputs:
-   domain: message
    id: out
asserts:
- ${ poly >= 0 }
- ${ poly < 256 }
- ${ seed >= 0 }
- ${ seed < 256 }

templates:
    imports: import ccsds
    make: ccsds.randomiser_softbits(${poly},${seed})

documentation: "Pseudo (De)randomiser\nCombines the input frame with a pseudo random\
    \ sequence by XOR operation. A one\nin the PRN sequence will invert the softbit,\
    \ a zero will copy it untouched. The\npseudo random sequence is generated by an\
    \ 8-bit linear feedback shift register \n(LFSR) as defined in ECSS.\n\nThe pseudo\
    \ random sequence can be modified by the generating polygon as well as\nshifted\
    \ by choosing a different initial seed state.\n\npoly: Polynomial that defines\
    \ the network of the 8 shift registers. The MSB\nencodes whether the last shift\
    \ register (which is used for the output) should be\nused to generate the new\
    \ input while the LSB encodes whether the first shift\nregister (that holds the\
    \ input bit of the last step should be used to generate\nthe output. Or in ECSS\
    \ definition: The MSB holds the coefficient for x^0 up to\nthe LSB which holds\
    \ coefficient x^7. x^8 is not encoded as it is always set (due\nto the fact that\
    \ this is a maximum length 8 bit shift register). The default\nvalue is 0x95 which\
    \ corresponds to the randomiser defined in ECSS with the\npolynomial representation\
    \ x^8+x^7+x^5+x^3+x^0.\n\nseed: Initial state of the shift registers. MSB corresponds\
    \ to the last register\n(which will be the output on the next step). Default to\t\
    all ones as defined in\nECSS."

file_format: 1
