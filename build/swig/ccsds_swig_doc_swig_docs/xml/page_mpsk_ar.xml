<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="page_mpsk_ar" kind="page">
    <compoundname>page_mpsk_ar</compoundname>
    <title>M-PSK Phase Ambiguity Resolution</title>
    <detaileddescription>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_introduction">
<title>Introduction</title>
<para>Phase ambiguity can be resolved by differential transmission or by a known pilot sequence in the received signal. This page deals with the latter case.</para><para>In CCSDS systems the transfer frames are prefixed with a repeating, known bit sequence: the attached sync marker (ASM) than can be used for ambiguity resolution (AR).</para><para>This package provides two AR blocks, one for hard-bit decisions and one for soft-bit decisions. Both work by creating all possible ambiguities of an incomming stream and then searching for a known pilot sequence in them. If the pilot sequence is found in one ambiguity stream and it is repeating in a known pattern (after every transfer frame in CCSDS signals) the right ambiguity is found and the stream with this ambiguity is send to the output of the AR block.</para></sect1>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_lock_threshold">
<title>Locking threshold</title>
<para>In order not to lose lock on a burst of bit errors both block can keep lock even after not finding the ASM at their expected position for several times (bit errors might still be corrected by later channelcoding blocks and thus the stream shall not be dropped). However when there is a cycle slip in the upstream PLL keeping up the lock although there are no ASMs anymore will result in frames beeing dropped because the downstream blocks still see the old ambiguity stream. So the selection of the locking threshold is a tradeoff</para></sect1>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_hard">
<title>Hard-bit Ambiguity Resolution</title>
<para>The hard-bit AR block implemented in (not implemented in gnuradio 3.7) is looking the ASM sequence in an input stream of unpacked bytes (ld(M) information bits per byte). The AR threads these unpacked bytes as symbols and not as individual bytes in order to be able to create all other possible ambiguities out of a symbol. In order to be robust against bit errors a configurable number of bit errors may occur in an ambiguity stream and the block will still recognize the ASM in it.</para></sect1>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_introduction">
<title>Introduction</title>
<para>Phase ambiguity can be resolved by differential transmission or by a known pilot sequence in the received signal. This page deals with the latter case.</para><para>In CCSDS systems the transfer frames are prefixed with a repeating, known bit sequence: the attached sync marker (ASM) than can be used for ambiguity resolution (AR).</para><para>This package provides two AR blocks, one for hard-bit decisions and one for soft-bit decisions. Both work by creating all possible ambiguities of an incomming stream and then searching for a known pilot sequence in them. If the pilot sequence is found in one ambiguity stream and it is repeating in a known pattern (after every transfer frame in CCSDS signals) the right ambiguity is found and the stream with this ambiguity is send to the output of the AR block.</para></sect1>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_lock_threshold">
<title>Locking threshold</title>
<para>In order not to lose lock on a burst of bit errors both block can keep lock even after not finding the ASM at their expected position for several times (bit errors might still be corrected by later channelcoding blocks and thus the stream shall not be dropped). However when there is a cycle slip in the upstream PLL keeping up the lock although there are no ASMs anymore will result in frames beeing dropped because the downstream blocks still see the old ambiguity stream. So the selection of the locking threshold is a tradeoff</para></sect1>
<sect1 id="page_mpsk_ar_1page_mpsk_ar_hard">
<title>Hard-bit Ambiguity Resolution</title>
<para>The hard-bit AR block implemented in <ref refid="classccsds__mpsk__ambiguity__resolver__bb" kindref="compound">ccsds_mpsk_ambiguity_resolver_bb</ref> is looking the ASM sequence in an input stream of unpacked bytes (ld(M) information bits per byte). The AR threads these unpacked bytes as symbols and not as individual bytes in order to be able to create all other possible ambiguities out of a symbol. In order to be robust against bit errors a configurable number of bit errors may occur in an ambiguity stream and the block will still recognize the ASM in it. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
