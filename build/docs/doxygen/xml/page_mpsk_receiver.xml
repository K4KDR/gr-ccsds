<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="page_mpsk_receiver" kind="page">
    <compoundname>page_mpsk_receiver</compoundname>
    <title>M-PSK demodulation chain</title>
    <innerpage refid="page_mpsk_ar">M-PSK Phase Ambiguity Resolution</innerpage>
    <innerpage refid="page_mpsk_ar">M-PSK Phase Ambiguity Resolution</innerpage>
    <innerpage refid="page_lo_feedback">Local oscillator frequency correction feedback loop</innerpage>
    <detaileddescription>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_introduction">
<title>Introduction</title>
<para>This pages describes two general purpose M-PSK demodulation chains which can be used to synchronize and demodulate arbitrary M-PSK signals. The first one is working on hard bit decisions(not implemented in gnuradio 3.7), while the latter on uses soft-bit decisions. These blocks are available as GRC blocks in <emphasis>apps/blocks/mpsk_demod_hard.grc</emphasis> and <emphasis>apps/blocks/mpsk_demod_soft.grc</emphasis> </para><para>The output of these two demodulators still have phase ambiguity, which has to be resolved either by differential encoding/decoding or by <ref refid="page_mpsk_ar" kindref="compound">M-PSK Phase Ambiguity Resolution</ref></para><sect2 id="page_mpsk_receiver_1page_mpsk_receiver_introduction_soft">
<title>Soft-bit Decisions</title>
<para>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized stream of soft-bits (with unresolved phase ambiguity). This is usually followed by the soft-bit decision M-PSK ambiguity resolver and frame synchronization block implemented in <ref refid="mpsk__ambiguity__resolver__f_8h" kindref="compound">ccsds/mpsk_ambiguity_resolver_f.h</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_introduction_hard_or_soft">
<title>Hard- or Soft-bit Decisions</title>
<para>Soft-bit decisions are recommended when following up with channelcoding (usually viterbi decoding) that can take advantage of the soft-bits. But the output of the soft-bit AR/FS block can also be cast back to hard-bit decisions with the <ref refid="softbits__msg__to__bytes__b_8h" kindref="compound">ccsds/softbits_msg_to_bytes_b.h</ref> block so blocks downstream can take hard-bit decisions even when the soft-bit demodulator chain was used. The advantage of this is that the AR and FS profit from the soft-bit correlation, but they meed more recources than using the hard-bit detector block.</para><para><xrefsect id="todo_1_todo000001"><xreftitle>Todo</xreftitle><xrefdescription><para>Put the ambiguity resolution and frame synchronization into this block as soon as Hierachial blocks can have message ports.</para></xrefdescription></xrefsect></para></sect2>
</sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_setup">
<title>Setup</title>
<para>The Figure below shows the GRC block of the soft-bit M-PSK demodulation chain. The hard-bit demodulation chain is identical to the soft-bit one except for a different detector and a byte stream instead of a float stream as output. Both&apos;s parameters and blocks are described in the next Sections.</para><para><image type="html" name="mpsk_demod_soft.png">Setup of the soft-bit M-PSK demodulation chain of this package</image>
 </para></sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_parameters">
<title>Parameters</title>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_samp_rate">
<title>samp_rate</title>
<para>The sampling rate of the incomming signal.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_M">
<title>M</title>
<para>The Modulation order of the signal. Must be a power of two. For BPSK (i.e. M=2) the previously developed BPSK demodulator <emphasis>bpsk_demod</emphasis> can be used as an alternative.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_osf">
<title>osf</title>
<para>Oversampling factor, or samples per symbol. The receiver block performs a decimation by this factor. Oversampling must be at least two.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_alpha">
<title>alpha</title>
<para>Rollof factor for the RX filter.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_asm">
<title>Attached sync marker (ASM)</title>
<para>The repeating sequence used for ambiguity resolution as a hex string. The sequence length must be an integer multiple of bytes and thus the string must contain an even number of characters.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_frame_len">
<title>Frame length</title>
<para>Length of the data between two sync markers in bytes.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_sym_rate">
<title>sym_rate</title>
<para>Symbol rate of the incomming signal given by <computeroutput>samp_rate</computeroutput> / <computeroutput>osf</computeroutput>.</para></sect2>
</sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_blocks">
<title>Blocks</title>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_filter">
<title>RX filter</title>
<para>The RX filter cuts out all frequency parts with a frequency higher than the symbol rate and thus filtering out all the noise that was introduced due to oversampling. The concatenation of this filter and the TX filter should fulfill the first Nyquist criterion. The two most common TX/RX filter combinations are a brick wall filter (or no filtering at all) at the TX side together with a raised cosine filter at the RX side, or a root raised cosine filter at each TX and RX side.</para><para>These two options are predefined in the block and by default the RRC filter is used. The raised cosine filter can be used by enabling the two RRC Filter path and disabling the single Root Raised Cosine Filter path.</para><para><xrefsect id="todo_1_todo000002"><xreftitle>Todo</xreftitle><xrefdescription><para>In the future this block should be able to switch between the two filters and leaving the GRC definition untouched. </para></xrefdescription></xrefsect></para><sect3 id="page_mpsk_receiver_1page_mpsk_receiver_filter_rrc">
<title>Root Raised Cosine Filter</title>
<para>A standard GRC RRC filter implementation is used.</para></sect3>
<sect3 id="page_mpsk_receiver_1page_mpsk_receiver_filter_rc">
<title>Raised Cosine Filter</title>
<para>There is no Raised Cosine filter block in GRC, the concatenation of two standard GRC RRC filters is used instead which is the same as using one RC filter.</para></sect3>
</sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_dll">
<title>Delay locked loop</title>
<para>Estimate the timing error introduced by a propagation delay and interpolate the signal at the correct time instances at symbol rate. This block performs a decimation by <computeroutput>osf</computeroutput>. The DLL is implemented in <ref refid="dll__cc_8h" kindref="compound">ccsds/dll_cc.h</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_agc2">
<title>Automatic Gain Control</title>
<para>The incomming signal energy can vary based on the TX power on the sending side and the attenuation between transmitter and receiver. At this point in the chain the relative power level between samples is no longer essential, so the overall signal level is regulated to have an average signal energy of 1. This is performed by this block. A standard GRC AGC2 implementation is used.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_pll">
<title>Phase locked loop</title>
<para>Estimates the signal&apos;s phase and local frequency offset (after the LO). Sends frequency corrections to the LO and compensates the phase offset of the samples. The PLL is implemented in <ref refid="pll__cc_8h" kindref="compound">ccsds/pll_cc.h</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_detector">
<title>M-PSK Detector</title>
<para>Detects the received M-PSK symbols based on the synchronized samples. Two different implementations are available.</para><sect3 id="page_mpsk_receiver_1page_mpsk_receiver_detector_hard">
<title>Hard-bit Detector</title>
<para>Performs hard bit decisions and outputs the detected bits in an unpacked bytes containing ld(M) information bits.</para></sect3>
<sect3 id="page_mpsk_receiver_1page_mpsk_receiver_detector_soft">
<title>Soft-bit Detector</title>
<para>Performs soft-bit decisions and outputs ld(M) soft-bit floats per incomming symbol. The soft bits range from -1.0f (very confident zero) over 0.0f (no confidence at all, this could either be a zero or a one) up to 1.0f (very confident one).</para></sect3>
</sect2>
</sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_introduction">
<title>Introduction</title>
<para>This pages describes two general purpose M-PSK demodulation chains which can be used to synchronize and demodulate arbitrary M-PSK signals. The first one is working on hard bit decisions, while the latter on uses soft-bit decisions. These blocks are available as GRC blocks in <emphasis>apps/blocks/mpsk_demod_hard.grc</emphasis> and <emphasis>apps/blocks/mpsk_demod_soft.grc</emphasis> </para><para>The output of these two demodulators still have phase ambiguity, which has to be resolved either by differential encoding/decoding or by <ref refid="page_mpsk_ar" kindref="compound">M-PSK Phase Ambiguity Resolution</ref></para><sect2 id="page_mpsk_receiver_1page_mpsk_receiver_introduction_hard">
<title>Hard-bit Decisions</title>
<para>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized, unpacked (ld(M) information bits per byte) stream of bits (with unresolved phase ambiguity). This block is usually followed by the hard decision M-PSK ambiguity resolver implemented in <ref refid="classccsds__mpsk__ambiguity__resolver__bb" kindref="compound">ccsds_mpsk_ambiguity_resolver_bb</ref> and the frame synchronization implemented in <ref refid="classccsds__frame__sync__b" kindref="compound">ccsds_frame_sync_b</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_introduction_soft">
<title>Soft-bit Decisions</title>
<para>This block takes an input stream of complex samples at sampling rate and outputs a bit synchronized stream of soft-bits (with unresolved phase ambiguity). This is usually followed by the soft-bit decision M-PSK ambiguity resolver and frame synchronization block implemented in <ref refid="classccsds__mpsk__ambiguity__resolver__f" kindref="compound">ccsds_mpsk_ambiguity_resolver_f</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_introduction_hard_or_soft">
<title>Hard- or Soft-bit Decisions</title>
<para>Soft-bit decisions are recommended when following up with channelcoding (usually viterbi decoding) that can take advantage of the soft-bits. But the output of the soft-bit AR/FS block can also be cast back to hard-bit decisions with the <ref refid="classccsds__softbits__msg__to__bytes__b" kindref="compound">ccsds_softbits_msg_to_bytes_b</ref> block so blocks downstream can take hard-bit decisions even when the soft-bit demodulator chain was used. The advantage of this is that the AR and FS profit from the soft-bit correlation, but they meed more recources than using the hard-bit detector block.</para><para><xrefsect id="todo_1_todo000004"><xreftitle>Todo</xreftitle><xrefdescription><para>Put the ambiguity resolution and frame synchronization into this block as soon as Hierachial blocks can have message ports.</para></xrefdescription></xrefsect></para></sect2>
</sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_setup">
<title>Setup</title>
<para>The Figure below shows the GRC block of the soft-bit M-PSK demodulation chain. The hard-bit demodulation chain is identical to the soft-bit one except for a different detector and a byte stream instead of a float stream as output. Both&apos;s parameters and blocks are described in the next Sections.</para><para><image type="html" name="mpsk_demod_soft.png">Setup of the soft-bit M-PSK demodulation chain of this package</image>
 </para></sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_parameters">
<title>Parameters</title>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_samp_rate">
<title>samp_rate</title>
<para>The sampling rate of the incomming signal.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_M">
<title>M</title>
<para>The Modulation order of the signal. Must be a power of two. For BPSK (i.e. M=2) the previously developed BPSK demodulator <emphasis>bpsk_demod</emphasis> can be used as an alternative.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_osf">
<title>osf</title>
<para>Oversampling factor, or samples per symbol. The receiver block performs a decimation by this factor. Oversampling must be at least two.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_alpha">
<title>alpha</title>
<para>Rollof factor for the RX filter.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_asm">
<title>Attached sync marker (ASM)</title>
<para>The repeating sequence used for ambiguity resolution as a hex string. The sequence length must be an integer multiple of bytes and thus the string must contain an even number of characters.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_frame_len">
<title>Frame length</title>
<para>Length of the data between two sync markers in bytes.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_sym_rate">
<title>sym_rate</title>
<para>Symbol rate of the incomming signal given by <computeroutput>samp_rate</computeroutput> / <computeroutput>osf</computeroutput>.</para></sect2>
</sect1>
<sect1 id="page_mpsk_receiver_1page_mpsk_receiver_blocks">
<title>Blocks</title>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_lo">
<title>Local oscillator</title>
<para>The local oscillator shifts the incomminc signal by a frequency estimate it receives over the <ref refid="page_lo_feedback" kindref="compound">Local oscillator frequency correction feedback loop</ref> . If no frequency error is received (at the start) it uses a zero frequency estimate and thus does nothing at all until it receives an estimate. The LO is implemented in <ref refid="classccsds__local__oscillator__cc" kindref="compound">ccsds_local_oscillator_cc</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_filter">
<title>RX filter</title>
<para>The RX filter cuts out all frequency parts with a frequency higher than the symbol rate and thus filtering out all the noise that was introduced due to oversampling. The concatenation of this filter and the TX filter should fulfill the first Nyquist criterion. The two most common TX/RX filter combinations are a brick wall filter (or no filtering at all) at the TX side together with a raised cosine filter at the RX side, or a root raised cosine filter at each TX and RX side.</para><para>These two options are predefined in the block and by default the RRC filter is used. The raised cosine filter can be used by enabling the two RRC Filter path and disabling the single Root Raised Cosine Filter path.</para><para><xrefsect id="todo_1_todo000005"><xreftitle>Todo</xreftitle><xrefdescription><para>In the future this block should be able to switch between the two filters and leaving the GRC definition untouched. </para></xrefdescription></xrefsect></para><sect3 id="page_mpsk_receiver_1page_mpsk_receiver_filter_rrc">
<title>Root Raised Cosine Filter</title>
<para>A standard GRC RRC filter implementation is used.</para></sect3>
<sect3 id="page_mpsk_receiver_1page_mpsk_receiver_filter_rc">
<title>Raised Cosine Filter</title>
<para>There is no Raised Cosine filter block in GRC, the concatenation of two standard GRC RRC filters is used instead which is the same as using one RC filter.</para></sect3>
</sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_dll">
<title>Delay locked loop</title>
<para>Estimate the timing error introduced by a propagation delay and interpolate the signal at the correct time instances at symbol rate. This block performs a decimation by <computeroutput>osf</computeroutput>. The DLL is implemented in <ref refid="classccsds__dll__cc" kindref="compound">ccsds_dll_cc</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_agc2">
<title>Automatic Gain Control</title>
<para>The incomming signal energy can vary based on the TX power on the sending side and the attenuation between transmitter and receiver. At this point in the chain the relative power level between samples is no longer essential, so the overall signal level is regulated to have an average signal energy of 1. This is performed by this block. A standard GRC AGC2 implementation is used.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_pll">
<title>Phase locked loop</title>
<para>Estimates the signal&apos;s phase and local frequency offset (after the LO). Sends frequency corrections to the LO and compensates the phase offset of the samples. The PLL is implemented in <ref refid="classccsds__pll__cc" kindref="compound">ccsds_pll_cc</ref>.</para></sect2>
<sect2 id="page_mpsk_receiver_1page_mpsk_receiver_detector">
<title>M-PSK Detector</title>
<para>Detects the received M-PSK symbols based on the synchronized samples. Two different implementations are available.</para><sect3 id="page_mpsk_receiver_1page_mpsk_receiver_detector_hard">
<title>Hard-bit Detector</title>
<para>Performs hard bit decisions and outputs the detected bits in an unpacked bytes containing ld(M) information bits.</para></sect3>
<sect3 id="page_mpsk_receiver_1page_mpsk_receiver_detector_soft">
<title>Soft-bit Detector</title>
<para>Performs soft-bit decisions and outputs ld(M) soft-bit floats per incomming symbol. The soft bits range from -1.0f (very confident zero) over 0.0f (no confidence at all, this could either be a zero or a one) up to 1.0f (very confident one). </para></sect3>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
